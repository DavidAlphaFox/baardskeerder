Details
=======

Concepts
--------
In this section, we review some concepts and vocabulary used throughout this
documentation and the Baardskeerder documentation.

Database
    A database is a set of on-disk files which contain the B-tree

Entry
    An entry is the smallest entity in the database file (note this is not a
    key/value-pair). It can be either a commit entry, a node entry or a value
    entry.

Slab
    A slab is a set of entries added to the database in a single CRUD action

Commit Entry
    A commit entry marks a finished transaction, and points to the root node
    entry of the tree generated by the transaction

Node Entry
    A node entry is an internal node

Value Entry
    A value entry stores a value, corresponding to a key in some version(s) of
    the tree

Transaction
    A transaction consists of a set of CRUD actions. A transaction is started
    at a certain point in time, and can be committed or rolled back after some
    actions have been performed.

Soft Compaction
    A soft compaction of a database doesn't compact the database files, unlike
    a full compaction, but lets the underlying filesystem know some data is no
    longer necessary (so-called 'hole punching')

Full Compaction
    A full compaction rewrites a database file, defragmenting entries on the go

Spindle
    A spindle denotes a single file, part of the database. When a database
    consists of multiple files, these should go in different devices (or
    spindles, when using rotating disks), for performance reasons. Multiple
    files on the same device can reduce performance.

Multi-set
    A multi-set is a single action combining multiple CRUD actions. These are
    applied on the tree in one go, reducing storage overhead and IO actions.

Hot Copy
    A hot copy of a database is a copy of the database, containing the tree as
    it was at a given point in time. A hot copy consists of the offsets of all
    spindles at the given file, and a copy of all spindles up to (or after)
    this offset.

fsck
    An fsck operation on a database allows both to check whether a given
    version of the database is consistent, as well as to figure out what the
    latest consistent version of the database is.


Implementation Considerations
-----------------------------
Statistics
~~~~~~~~~~
Implement statistics collection and reporting from day 1 in the implementation.

Consistency / Safety Guarantees
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Decide on when/where to add f(data)sync(2) calls etc. Make this configurable?

Optimization Considerations
---------------------------
Common Prefix Elimination in Branches
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Value Compression
~~~~~~~~~~~~~~~~~
Pro: Storage decrease
Pro: Reduce IO blocks read
Con: Can't use splice(2)

Use fallocate(2)
~~~~~~~~~~~~~~~~
Pre-allocate extents before writing into them. Might have some performance
benefit and reduce fragmentation. Transaction abort using ftruncate(2) would
still work.

Random Thoughts
---------------
Metadata Pages
~~~~~~~~~~~~~~
Keep metadata (incl. pointer to some recent valid root) in 2 pages at
beginning of file (cfr. CouchDB), which are synced (e.g. using
sync_file_range(2)) safely.

Include Checksums
~~~~~~~~~~~~~~~~~
Enable consistency checks.

Store Value Length Inside Branches
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Storing pointers to leaf nodes as (offset, length) tuples removes a read operation (used to retrieve value length otherwise), and allows for splice(2)'d operations without any read(2) inside the leaf node.

Pro: Reduce # IO calls
Con: Some space increase. Using 24-bit lengths allows for 16MB values, is this sufficient? Consider Rice/Golomb coding?

Multi-Device Storage
~~~~~~~~~~~~~~~~~~~~
When using multiple storage devices, interleave leaf/branch writes across several devices (heads), making sure the amount of data written to each device is spread equally.

Pro: Performance
Con: Single disk failure results in complete database loss (not sure this is a real 'con', though -> same goes for single-disk databases)
